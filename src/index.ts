'use strict'

import Deltaframe from 'deltaframe';
import button from './button/button';
import Mousebind from './button/Mousebind';
import MousebindObject from './interfaces/MousebindObject';

/**
 * TODO
 */
export default class Mousehawk {

  /**
   * A reference to the options for this instance of Mousehawk.
   * 
   * @property {Options}
   */
  private _options: any;

  /**
   * A list of mouse buttons that can be used to create mousebinds.
   * 
   * @property {MOUSE}
   * 
   * @private
   */
  private _BUTTON: any = button;

  /**
   * A list of the created mousebinds.
   * 
   * @property {Array<Mousebind>}
   * 
   * @private
   * 
   * @default []
   */
  private _mousebinds: Array<Mousebind> = [];

  /**
   * Keeps track of what mouse buttons have been pressed.
   * 
   * @property {Object}
   * 
   * @private
   */
  private _pressed: any = {};

  /**
   * Indicates whether using mousebinds are currently disabled or not.
   * 
   * @property {boolean}
   * 
   * @private
   * 
   * @default false
   */
  private _disabled: boolean = false;

  /**
   * The amount of time that mousebinds are disabled for if any.
   * 
   * @property {number}
   * 
   * @private
   * 
   * @default 0
   */
  private _disabledTime: number = 0;

  /**
   * A reference to the Deltaframe game loop.
   * 
   * @property {Deltaframe}
   * 
   * @private
   */
  private _loop: Deltaframe = new Deltaframe();

  constructor() {

    this._boot();

  }

  /**
   * Gets the mouse buttons that can be used to create mousebinds.
   * 
   * @returns {*}
   */
  get BUTTON(): any {

    return this._BUTTON;

  }

  /**
   * Setup the mousedown and mouseup event listeners and also initialize Deltaframe if its being used.
   * 
   * @private
   */
  private _boot() {

    window.addEventListener('mousedown', (ev: MouseEvent) => this._onmousedown(ev));

    window.addEventListener('mouseup', (ev: MouseEvent) => this._onmouseup(ev));

    this._loop.start((time: number) => this.check(time));

  }

  /**
   * When a mouse button is pressed, add it to the `pressed` object if it doesn't already exist and set it to `true`.
   * 
   * @private
   * 
   * @param {MouseEvent} ev The MouseEvent generated by the mouse button press.
   */
  private _onmousedown(ev: MouseEvent) {

    this._pressed[ev.buttons] = true;

    ev.preventDefault();

  }

  /**
   * When a mouse button is released, set its property in the `pressed` object to `false`.
   * 
   * @private
   * 
   * @param {MouseEvent} ev The MouseEvent generated by the mouse button press.
   */
  private _onmouseup(ev: MouseEvent) {

    this._pressed[ev.buttons] = false;

    ev.preventDefault();

  }

  /**
   * Creates a new mousebind for the specified mouse button.
   * 
   * @param {MousebindObject} mouseButton One or more mouse buttons from the `BUTTONS` property to attach to this mousebind.
   * 
   * @returns {Mousebind} Returns the newly created mousebind.
   */
  mousebind(mouseButton: MousebindObject) {

    if (!mouseButton) {

      console.warn('A mouse button must be provided to create a mousebind');

      return;

    }

    const mouseObj: MousebindObject = {};

    const mousebind: Mousebind = new Mousebind(mouseButton);

    this._mousebinds.push(mousebind);

    return mousebind;

  }

	/**
	 * Checks to see which mouse button conditions are currently being met and runs the mousebinds's attached callback method.
   * 
   * @param {number} time The current timestamp which is used to check for delays and is passed to the mousebinds's callback method.
	 */
  check(time: number) {

    this._mousebinds.map(bind => {

      const button: string = bind.button.toString();

      const isActive: boolean = this._pressed[button];

      const isPastInitialDelay: boolean = time > bind._initialDelay;

      const isTime: boolean = time - bind.lastUsed > bind._delay;

      if (this._disabled) {

        if (time < time + this._disabledTime) return;

        else this.enable();

      }

      if (isActive && isPastInitialDelay && isTime && bind.action) bind.run(time);

    });

  }

  /**
   * Disables the use of all mousebinds until enable is called or until the wait time has expired if it is provided.
   * 
   * @param {number} [lengthOfTime=Infinity] An optional amount of time to wait until mousebinds are automatically enabled again. 
   */
  disable(lengthOfTime: number = Infinity) {

    this._disabled = true;

    this._disabledTime = lengthOfTime;

  }

  /**
   * If no end time is passed when calling the `disable` method, this method has to be called to enable the use of
   * mousebind again.
   */
  enable() {

    this._disabled = false

    this._disabledTime = 0;


  }

};